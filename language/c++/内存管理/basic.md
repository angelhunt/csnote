
可能导致内存泄露的大概有以下情况

析构函数调用前线程崩溃，导致析构函数没有被调用
使用引用计数时，构造了循环引用

在变量初始化时，调用构造函数分配资源；在变量析构时，调用析构函数释放其持有的资源。其实在资源管理中，后半句才是关键，因为获取资源是手动的，释放资源是自动的

在变量作用域结束的时候，编译器会自动帮我们加上对析构函数的调用


# RAII 

般我们说GC的时候，是狭义地指tracing garbage collection，也是最常见的GC；而对于reference counting，一般称之为RC。

没有引用遍历的stop the world停顿；但是如果真用最简单直观的方式实现RC，在出现循环引用时会造成内存泄露，多线程时频繁的原子性增减操作会降低运行效率，最后在处理的吞吐量上一般不如GC。

RAII相对与GC的优势之一显然是性能和实时性更高，消耗更小,RAII能够管理所有种类的资源，而GC只能管理内存。除了内存以外的资源具有唯一性，如我要访问的文件或者申请的同步锁，都是需要特定的那一个；


对于内存以外资源的管理，使用GC的语言往往有如下方式进行管理。

手动释放
加入一些关键词，局部引入RAII（比全局默认的RAII要多写些东西）


RAII的缺陷在于，有些数据的生命周期更加动态，在运行时才能确定，RAII就不太好对它们进行有效的管理。

此时需要那就是需要引入GC（广义的）。Rust在这里使用RC进行辅助的内存管理，处理那些生命周期更加动态的资源。