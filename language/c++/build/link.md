# abi问题


当我们的应用程序引用了一个以二进制形式发布的库时，在源代码层面，我们使用了这个库的 API；而在编译、链接之后，在运行时，我们的应用程序通过 ABI 在与这个库通信。从这个角度看来，ABI 只是 API 的底层实现，不同的编译器，机器对这个abi都有不同的实现，所以不同平台甚至不同编译器下的library可能都无法公用。
调用函数过程设计栈的管理和寄存器的应用，哪个参数放在AX里面，哪个放在BX里面，函数返回值在哪个寄存器里面，这个函数调用方和被调用方需要协商一致，这个就是ABI的一部分.
应用程序二进制接口是一套规则，规定了二进制可执行文件在运行时应如何与某些服务（诸如内核或函数库所提供的服务）交换信息。ABI特别规定了哪些使用寄存器和栈地址来交换信息以及所交换值的含义，一旦针对某个规定的ABI进行了编译，其二进制可执行文件应能在ABI相同的任何系统上运行。




我们把符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为ABI(Application Binary Interface)。

1. name mangling, 用于符号匹配，编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整(mangling)，而相反的过程叫做恢复(demangling) 
2. calling convension, 当你选择了一个函数，你还要知道参数怎么传，返回值放哪里，栈由谁清理，编译器决定


可以手动指定一些特别的调用约定，几个编译器之间只要支持就不会在这个地方发生兼容问题。
此外，不同的架构（如x86和arm，x86的32位/64位）有着不同的资源/寄存器，也会导致calling convension的不同。相互之间机器码不能互相兼容，所以也要纳入ABI的考量。


那么当人们提到 ABI 的时候，到底在说什么？以我个人的经验来看，当人们提及 ABI 时，一般主要是在说 Binary-compatible 即二进制兼容性。什么是二进制兼容性呢？这个问题牵扯的比较广。举例来说，假设你的应用程序引用的一个库某天更新了，虽然 API 和调用方式基本没变，但你需要重新编译你的应用程序才能使用这个库，那么一般说这个库是 Source compatible；反之，如果不需要重新编译应用程序就能使用新版本的库，那么说这个库跟它之前的版本是二进制兼容的。再举个例子：一个库在 VC9 上完成编译并以 DLL 形式发布，如果该库要求使用它的应用程序也必须在 VC9 上编译，那么说这个库不是二进制兼容的；反之，如果任意版本的 VC 乃至其它编译器例如 gcc、clang 都可以使用这个库，那么说这个库是二进制兼容的。



https://www.zhihu.com/question/381069847

